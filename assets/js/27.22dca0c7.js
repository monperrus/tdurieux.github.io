(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{245:function(e,t,a){"use strict";a.r(t);var r=a(2),s=Object(r.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"research"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#research","aria-hidden":"true"}},[e._v("#")]),e._v(" RESEARCH")]),e._v(" "),a("p",[e._v("I'm currently working in the research field of Software Engineering.\nI'm working on new patch generation and fault localization techniques.\nI'm particularly interested in the integration of the patch generation technique in the production environment.")]),e._v(" "),a("h2",{attrs:{id:"publications"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#publications","aria-hidden":"true"}},[e._v("#")]),e._v(" PUBLICATIONS")]),e._v(" "),a("h3",{attrs:{id:"_2021-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2021-4","aria-hidden":"true"}},[e._v("#")]),e._v(" 2021 (4)")]),e._v(" "),a("ul",[a("li",[a("p",[a("cv",{attrs:{name:"A Longitudinal Analysis of Bloated Java Dependencies",url:"",date:"2021",description:"Motivated by the negative impact of software bloat on security, performance, and maintenance, several works have proposed techniques to remove bloat. However, no work has analyzed how bloat evolves over time or how it emerges in software projects. In particular, a concern when removing bloated code is to know if it might be useful in subsequent versions of the application. In this work, we study the evolution and emergence of bloated Java dependencies. These are third-party libraries that are packaged in the application binary but are not needed to run the application. We analyze the history of 435 Java projects. This historical data includes 48,469 distinct dependencies, which we study across a total of 31,515 versions of Maven dependency trees. We empirically demonstrate the constant increase of the amount of bloated dependencies over time. A key finding of our analysis is that 89.2% of the direct dependencies that are bloated remain bloated in all subsequent versions of the studied projects. This empirical evidence suggests that developers can safely remove a bloated dependency. We further report novel insights regarding the unnecessary maintenance efforts induced by bloat, we identify that 22% of dependency updates are made on bloated dependencies.",authors:[{lastname:"César",firstname:"Soto Valero",url:"https://www.cesarsotovalero.net/"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Baudry",firstname:"Benoit",url:"https://softwarediversity.eu/"}],role:"Proceedings of the 29th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE '21)"}})],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"A large-scale study on human-cloned changes for automated program repair",url:"https://arxiv.org/abs/2104.02386",date:"2021",description:"Research in automatic program repair has shown that real bugs can be automatically fixed. However, there are several challenges involved in such a task that are not yet fully addressed. As an example, consider that a test-suite-based repair tool performs a change in a program to fix a bug spotted by a failing test case, but then the same or another test case fails. This could mean that the change is a partial fix for the bug or that another bug was manifested. However, the repair tool discards the change and possibly performs other repair attempts. One might wonder if the applied change should be also applied in other locations in the program so that the bug is fully fixed. In this paper, we are interested in investigating the extent of bug fix changes being cloned by developers within patches. Our goal is to investigate the need of multi-location repair by using identical or similar changes in identical or similar contexts. To do so, we analyzed 3,049 multi-hunk patches from the ManySStuBs4J dataset, which is a large dataset of single statement bug fix changes. We found out that 68% of the multi-hunk patches contain at least one change clone group. Moreover, most of these patches (70%) are strictly-cloned ones, which are patches fully composed of changes belonging to one single change clone group. Finally, most of the strictly-cloned patches (89%) contain change clones with identical changes, independently of their contexts. We conclude that automated solutions for creating patches composed of identical or similar changes can be useful for fixing bugs.",authors:[{lastname:"Madeiral",firstname:"Fernanda",url:"https://fermadeiral.github.io/"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"}],acceptance:"66%, 8/12",role:"Proceedings of the 18th International Conference on Mining Software Repositories (MSR '21)"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/2104.02386",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/software-bugs/change-clone",target:"_blank",rel:"noopener noreferrer"}},[e._v("Experiment Results"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"DUETS: A Dataset of Reproducible Pairs of Java Library-Clients",url:"http://arxiv.org/abs/2103.09672",date:"2021",description:"Software engineering researchers look for software artifacts to study their characteristics or to evaluate new techniques. In this paper, we introduce DUETS, a new dataset of software libraries and their clients. This dataset can be exploited to gain many different insights, such as API usage, usage inputs, or novel observations about the test suites of clients and libraries. DUETS is meant to support both static and dynamic analysis. This means that the libraries and the clients compile correctly, they are executable and their test suites pass. The dataset is composed of open-source projects that have more than five stars on GitHub. The final dataset contains 395 libraries and 2,874 clients. Additionally, we provide the raw data that we use to create this dataset, such as 34,560 pom.xml files or the complete file list from 34,560 projects. This dataset can be used to study how libraries are used by their clients or as a list of software projects that succesfully build. The client’s test suite can be used as an additional verification step for code transformation techniques that modify the libraries.",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"César",firstname:"Soto Valero",url:"https://www.cesarsotovalero.net/"},{lastname:"Baudry",firstname:"Benoit",url:"https://softwarediversity.eu/"}],role:"Proceedings of the 18th International Conference on Mining Software Repositories (MSR '21)"}}),e._v(" "),a("a",{attrs:{href:"http://arxiv.org/abs/2103.09672",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/castor-software/Duets",target:"_blank",rel:"noopener noreferrer"}},[e._v("Dataset"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Automated Classification of Overfitting Patches with Statically Extracted Code Features",url:"https://arxiv.org/abs/1910.12057",date:"2021",description:"Automatic program repair (APR) aims to reduce the cost of manually fixing software defects. However, APR suffers from generating a multitude of overfitting patches, those patches that fail to correctly repair the defect beyond making the tests pass. This paper presents a novel overfitting patch detection system called ODS to assess the correctness of APR patches. ODS first statically compares a patched program and a buggy program in order to extract code features at the abstract syntax tree (AST) level. Then, ODS uses supervised learning with the captured code features and patch correctness labels to automatically learn a probabilistic model. The learned ODS model can then finally be applied to classify new and unseen program repair patches. We conduct a large-scale experiment to evaluate the effectiveness of ODS on patch correctness classification based on 10,302 patches from Defects4J, Bugs.jar and Bears benchmarks. The empirical evaluation shows that ODS is able to correctly classify 71.9% of program repair patches from 26 projects, which improves the state-of-the-art. ODS is applicable in practice and can be employed as a post-processing procedure to classify the patches generated by different APR systems.",authors:[{lastname:"Ye",firstname:"He",url:"https://www.kth.se/profile/heye"},{lastname:"Gu",firstname:"Jian"},{lastname:"Martinez",firstname:"Matias",url:"http://www.martinezmatias.com"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],role:"IEEE Transactions on Software Engineering"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/1910.12057",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/kth-tcs/overfitting-analysis",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"A comprehensive study of automatic program repair on the QuixBugs benchmark",url:"https://arxiv.org/abs/1805.03454",date:"2021",description:"Automatic program repair papers tend to repeatedly use the same benchmarks. This poses a threat to the external validity of the findings of the program repair research community. In this paper, we perform an empirical study of automatic repair on a benchmark of bugs called QuixBugs, which has been little studied. In this paper, (1) We report on the characteristics of QuixBugs; (2) We study the effectiveness of 10 program repair tools on it; (3) We apply three patch correctness assessment techniques to comprehensively study the presence of overfitting patches in QuixBugs. Our key results are: (1) 16/40 buggy programs in QuixBugs can be repaired with at least a test suite adequate patch; (2) A total of 338 plausible patches are generated on the QuixBugs by the considered tools, and 53.3% of them are overfitting patches according to our manual assessment; (3) The three automated patch correctness assessment techniques, RGTEvosuite, RGTInputSampling and GTInvariants, achieve an accuracy of 98.2%, 80.8% and 58.3% in overfitting detection, respectively. To our knowledge, this is the largest empirical study of automatic repair on QuixBugs, combining both quantitative and qualitative insights. All our empirical results are publicly available on GitHub in order to facilitate future research on automatic program repair.",authors:[{lastname:"Ye",firstname:"He",url:"https://www.kth.se/profile/heye"},{lastname:"Martinez",firstname:"Matias",url:"http://www.martinezmatias.com"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],role:"Journal of Systems and Software"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/1805.03454",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/KTH/quixbugs-experiment",target:"_blank",rel:"noopener noreferrer"}},[e._v("Experiment Results"),a("OutboundLink")],1)],1)])]),e._v(" "),a("h3",{attrs:{id:"_2020-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2020-4","aria-hidden":"true"}},[e._v("#")]),e._v(" 2020 (4)")]),e._v(" "),a("ul",[a("li",[a("p",[a("cv",{attrs:{name:"SmartBugs: a framework to analyze solidity smart contracts",url:"https://dl.acm.org/doi/10.1145/3324884.3415298",date:"2020",description:"Over the last few years, there has been substantial research on automated analysis, testing, and debugging of Ethereum smart contracts. However, it is not trivial to compare and reproduce that research. To address this, we present an empirical evaluation of 9 state-of-the-art automated analysis tools using two new datasets: i) a dataset of 69 annotated vulnerable smart contracts that can be used to evaluate the precision of analysis tools; and ii) a dataset with all the smart contracts in the Ethereum Blockchain that have Solidity source code available on Etherscan (a total of 47,518 contracts). The datasets are part of SmartBugs, a new extendable execution framework that we created to facilitate the integration and comparison between multiple analysis tools and the analysis of Ethereum smart contracts. We used SmartBugs to execute the 9 automated analysis tools on the two datasets. In total, we ran 428,337 analyses that took approximately 564 days and 3 hours, being the largest experimental setup to date both in the number of tools and in execution time. We found that only 42% of the vulnerabilities from our annotated dataset are detected by all the tools, with the tool Mythril having the higher accuracy (27%). When considering the largest dataset, we observed that 97% of contracts are tagged as vulnerable, thus suggesting a considerable number of false positives. Indeed, only a small number of vulnerabilities (and of only two categories) were detected simultaneously by four or more tools.",authors:[{lastname:"Ferreira",firstname:"João F."},{lastname:"Cruz",firstname:"Pedro"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Rui",firstname:"Abreu",url:"https://ruimaranhao.github.io"}],acceptance:"62%, 18/29",role:"Proceedings of the 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)"}}),e._v(" "),a("a",{attrs:{href:"https://github.com/smartbugs/smartbugs",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://smartbugs.github.io",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebSite"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Empirical Study of Restarted and Flaky Builds on Travis CI",url:"https://arxiv.org/abs/2003.11772",date:"2020",description:"Continuous Integration (CI) is a development practice where developers frequently integrate code into a common codebase. After the code is integrated, the CI server runs a test suite and other tools to produce a set of reports (e.g., output of linters and tests). If the result of a CI test run is unexpected, developers have the option to manually restart the build, re-running the same test suite on the same code; this can reveal build flakiness, if the restarted build outcome differs from the original build. In this study, we analyze restarted builds, flaky builds, and their impact on the development workflow. We observe that developers restart at least 1.72% of builds, amounting to 56,522 restarted builds in our Travis CI dataset. We observe that more mature and more complex projects are more likely to include restarted builds. The restarted builds are mostly builds that are initially failing due to a test, network problem, or a Travis CI limitations such as execution timeout. Finally, we observe that restarted builds have a major impact on development workflow. Indeed, in 54.42% of the restarted builds, the developers analyze and restart a build within an hour of the initial failure. This suggests that developers wait for CI results, interrupting their workflow to address the issue. Restarted builds also slow down the merging of pull requests by a factor of three, bringing median merging time from 16h to 48h.",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Le Goues",firstname:"Claire",url:"https://clairelegoues.com/"},{lastname:"Hilton",firstname:"Michael",url:"https://www.cs.cmu.edu/~mhilton/"},{lastname:"Rui",firstname:"Abreu",url:"https://ruimaranhao.github.io"}],acceptance:"30%, 41/138",role:"Proceedings of the 17th International Conference on Mining Software Repositories (MSR '20)"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/2003.11772",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/tdurieux/Travis-Listener",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://zenodo.org/record/3601137",target:"_blank",rel:"noopener noreferrer"}},[e._v("Experiment Results"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Fully Automated HTML and Javascript Rewriting for Constructing a Self-healing Web Proxy",url:"https://arxiv.org/abs/1910.10601",date:"2020",description:"Over the last few years, the complexity of web applications has increased to provide more dynamic web applications to users. The drawback of this complexity is the growing number of errors in the front-end applications. In this paper, we present an approach to provide self-healing for the web. We implemented this approach in two different tools: 1) BikiniProxy, an HTTP repair proxy, and 2) BugBlock, a browser extension. They use five self-healing strategies to rewrite the buggy HTML and Javascript code to handle errors in web pages. We evaluate BikiniProxy and BugBlock with a new benchmark of 555 reproducible Javascript errors of which 31.76% can be automatically self-healed by BikiniProxy and 15.67% by BugBlock.",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Hamadi",firstname:"Youssef",url:"https://www.msr-inria.fr/researchers/youssef-hamadi/"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],role:"Proceedings at Software Testing, Verification & Reliability (STVR)"}}),e._v(" "),a("a",{attrs:{href:"https://github.com/Spirals-Team/bikiniproxy/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Empirical Review of Automated Analysis Tools on 47,587 Ethereum Smart Contracts",url:"https://arxiv.org/abs/1910.10601",date:"2020",description:"Over the last few years, there has been substantial research on automated analysis, testing, and debugging of Ethereum smart contracts. However, it is not trivial to compare and reproduce that research. To address this, we present an empirical evaluation of 9 state-of-the-art automated analysis tools using two new datasets: i) a dataset of 69 annotated vulnerable smart contracts that can be used to evaluate the precision of analysis tools; and ii) a dataset with all the smart contracts in the Ethereum Blockchain that have Solidity source code available on Etherscan (a total of 47,518 contracts). The datasets are part of SmartBugs, a new extendable execution framework that we created to facilitate the integration and comparison between multiple analysis tools and the analysis of Ethereum smart contracts. We used SmartBugs to execute the 9 automated analysis tools on the two datasets. In total, we ran 428,337 analyses that took approximately 564 days and 3 hours, being the largest experimental setup to date both in the number of tools and in execution time. We found that only 42% of the vulnerabilities from our annotated dataset are detected by all the tools, with the tool Mythril having the higher accuracy (27%). When considering the largest dataset, we observed that 97% of contracts are tagged as vulnerable, thus suggesting a considerable number of false positives. Indeed, only a small number of vulnerabilities (and of only two categories) were detected simultaneously by four or more tools.",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Ferreira",firstname:"João F."},{lastname:"Rui",firstname:"Abreu",url:"https://ruimaranhao.github.io"},{lastname:"Cruz",firstname:"Pedro"}],acceptance:"20%, 129/617",role:"Proceedings of the 42nd International Conference on Software Engineering (ICSE '20)"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/1910.10601",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/smartbugs/smartbugs",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/smartbugs/smartbugs-results",target:"_blank",rel:"noopener noreferrer"}},[e._v("Experiment Results"),a("OutboundLink")],1),e._v("  • "),a("a",{attrs:{href:"https://smartbugs.github.io",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebSite"),a("OutboundLink")],1)],1)])]),e._v(" "),a("h3",{attrs:{id:"_2019-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-4","aria-hidden":"true"}},[e._v("#")]),e._v(" 2019 (4)")]),e._v(" "),a("ul",[a("li",[a("p",[a("cv",{attrs:{name:"An Analysis of 35+ Million Jobs of Travis CI",url:"https://arxiv.org/abs/1904.09416",date:"2019",description:"Travis CI handles automatically thousands of builds every day to, amongst other things, provide valuable feedback to thousands of open-source developers. In this paper, we investigate Travis CI to firstly understand who is using it, and when they start to use it. Secondly, we investigate how the developers use Travis CI and finally, how frequently the developers change the Travis CI configurations. We observed during our analysis that the main users of Travis CI are corporate users such as Microsoft. And the programming languages used in Travis CI by those users do not follow the same popularity trend than on GitHub, for example, Python is the most popular language on Travis CI, but it is only the third one on GitHub. We also observe that Travis CI is set up on average seven days after the creation of the repository and the jobs are still mainly used (60%) to run tests. And finally, we observe that 7.34% of the commits modify the Travis CI configuration. We share the biggest benchmark of Travis CI jobs (to our knowledge): it contains 35,793,144 jobs from 272,917 different GitHub projects.",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Rui",firstname:"Abreu",url:"https://ruimaranhao.github.io"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"},{lastname:"Bissyandé, ",firstname:"Tegawendé F."},{lastname:"Cruz",firstname:"Luís"}],acceptance:"56%, 26/46",role:"Proceedings of the 35th IEEE International Conference on Software Maintenance and Evolution (ICSME'19)"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/1905.11973",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"/slide_35m_travis_jobs.pdf"}},[e._v("Slide")]),e._v(" • "),a("a",{attrs:{href:"https://github.com/tdurieux/travis-listener",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://zenodo.org/record/2560966",target:"_blank",rel:"noopener noreferrer"}},[e._v("Benchmark"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Repairnator patches programs automatically",url:"https://dl.acm.org/citation.cfm?doid=3345321.3349589",date:"2019",description:"Repairnator is a bot. It constantly monitors software bugs discovered during continuous integration of open-source software and tries to fix them automatically. If it succeeds in synthesizing a valid patch, Repairnator proposes the patch to the human developers, disguised under a fake human identity. To date, Repairnator has been able to produce patches that were accepted by the human developers and permanently merged into the code base. This is a milestone for human-competitiveness in software engineering research on automatic program repair.",authors:[{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"},{lastname:"Urli",firstname:"Simon"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Martinez",firstname:"Matias",url:"http://www.martinezmatias.com"},{lastname:"Baudry",firstname:"Benoit",url:"https://softwarediversity.eu/"},{lastname:"Seinturier",firstname:"Lionel",url:"http://chercheurs.lille.inria.fr/~seinturi/"}],acceptance:"",role:"ACM Ubiquity"}}),e._v(" "),a("a",{attrs:{href:"https://github.com/Spirals-Team/repairnator/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Empirical Review of Java Program Repair Tools: A Large-Scale Experiment on 2,141 Bugs and 23,551 Repair Attempts",url:"https://arxiv.org/abs/1905.11973",date:"2019",description:"In the past decade, research on test-suite-based automatic program repair has grown significantly. Each year, new approaches and implementations are featured in major software engineering venues. However, most of those approaches are evaluated on a single benchmark of bugs, which are also rarely reproduced by other researchers. In this paper, we present a large-scale experiment using 11 Java test-suite-based repair tools and 5 benchmarks of bugs. Our goal is to have a better understanding of the current state of automatic program repair tools on a large diversity of benchmarks. Our investigation is guided by the hypothesis that the repairability of repair tools might not be generalized across different benchmarks of bugs. We found that the 11 tools 1) are able to generate patches for 21% of the bugs from the 5 benchmarks, and 2) have better performance on Defects4J compared to other benchmarks, by generating patches for 47% of the bugs from Defects4J compared to 10-30% of bugs from the other benchmarks. Our experiment comprises 23,551 repair attempts in total, which we used to find the causes of non-patch generation. These causes are reported in this paper, which can help repair tool designers to improve their techniques and tools.",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Madeiral",firstname:"Fernanda",url:"https://fermadeiral.github.io/"},{lastname:"Martinez",firstname:"Matias",url:"http://www.martinezmatias.com"},{lastname:"Rui",firstname:"Abreu",url:"https://ruimaranhao.github.io"}],acceptance:"24%, 73/303",role:"Proceedings of the 27th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE '19)"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/1905.11973",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"/slide_repairthemall.pdf"}},[e._v("Slide")]),e._v(" • "),a("a",{attrs:{href:"https://github.com/program-repair/RepairThemAll",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/program-repair/RepairThemAll_experiment/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Experiment Results"),a("OutboundLink")],1),e._v("  • "),a("a",{attrs:{href:"http://program-repair.org/RepairThemAll_experiment/",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebSite"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"A Comprehensive Study of Automatic Program Repair on the QuixBugs Benchmark",url:"https://arxiv.org/abs/1807.11286",date:"2019",description:"Automatic program repair papers tend to repeatedly use the same benchmarks. This poses a threat to the external validity of the findings of the program repair research community. In this paper, we perform an automatic repair experiment on a benchmark called QuixBugs that has never been studied in the context of program repair. In this study, we report on the characteristics of QuixBugs, and study five repair systems, Arja, Astor, Nopol, NPEFix and RSRepair, which are representatives of generate-and-validate repair techniques and synthesis repair techniques. We propose three patch correctness assessment techniques to comprehensively study overfitting and incorrect patches. Our key results are: 1) 15 / 40 buggy programs in the QuixBugs can be repaired with a test-suite adequate patch; 2) a total of 64 plausible patches for those 15 buggy programs in the QuixBugs are present in the search space of the considered tools; 3) the three patch assessment techniques discard in total 33 / 64 patches that are overfitting. This sets a baseline for future research of automatic repair on QuixBugs. Our experiment also highlights the major properties and challenges of how to perform automated correctness assessment of program repair patches. All experimental results are publicly available on Github in order to facilitate future research on automatic program repair.",authors:[{lastname:"Ye",firstname:"He",url:"https://www.kth.se/profile/heye"},{lastname:"Martinez",firstname:"Matias",url:"http://www.martinezmatias.com"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],acceptance:"",role:"Proceedings in International Workshop on Intelligent Bug Fixing (IBF 2019), co-located with SANER2019"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/1805.03454",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/KTH/quixbugs-experiment",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1)],1)])]),e._v(" "),a("h3",{attrs:{id:"_2018-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2018-5","aria-hidden":"true"}},[e._v("#")]),e._v(" 2018 (5)")]),e._v(" "),a("ul",[a("li",[a("p",[a("cv",{attrs:{name:"Towards an automated approach for bug fix pattern detection",url:"https://arxiv.org/abs/1807.11286",date:"2018",description:"The characterization of bug datasets is essential to support the evaluation of automatic program repair tools. In a previous work, we manually studied almost 400 human-written patches (bug fixes) from the Defects4J dataset and annotated them with properties, such as repair patterns. However, manually finding these patterns in different datasets is tedious and time-consuming. To address this activity, we designed and implemented PPD, a detector of repair patterns in patches, which performs source code change analysis at abstract-syntax tree level. In this paper, we report on PPD and its evaluation on Defects4J, where we compare the results from the automated detection with the results from the previous manual analysis. We found that PPD has overall precision of 91% and overall recall of 92%, and we conclude that PPD has the potential to detect as many repair patterns as human manual analysis.",authors:[{lastname:"Madeiral",firstname:"Fernanda",url:"https://fermadeiral.github.io/"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Sobreira",firstname:"Victor"},{lastname:"Maia",firstname:"Marcelo de Almeida",url:"http://lascam.facom.ufu.br/"}],acceptance:"61%, 24/39",role:"Proceedings of the VI Workshop on Software Visualization, Evolution and Maintenance (VEM 2018)"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/1807.11286",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"/slide_ppd.pdf"}},[e._v("Slide")]),e._v(" • "),a("a",{attrs:{href:"https://github.com/lascam-UFU/automatic-diff-dissection",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Fully Automated HTML and Javascript Rewriting for Constructing a Self-healing Web Proxy",url:"https://arxiv.org/abs/1803.08725",date:"2018",description:"Over the last few years, the complexity of web applications has increased to provide more dynamic web applications to users. The drawback of this complexity is the growing number of errors in the front-end applications. In this paper, we present BikiniProxy, a novel technique to provide self-healing for the web. BikiniProxy is designed as an HTTP proxy that uses five self-healing strategies to rewrite the buggy HTML and Javascript code. We evaluate BikiniProxy with a new benchmark of 555 reproducible Javascript errors, DeadClick. We create DeadClick by randomly crawling the Internet and collect all web pages that contain Javascript errors. Then, we observe how BikiniProxy heals those errors by collecting and comparing the traces of the original and healed pages. To sum up, BikiniProxy is a novel fully-automated self-healing approach that is specific to the web, evaluated on 555 real Javascript errors, and based on original self-healing rewriting strategies for HTML and Javascript.",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Hamadi",firstname:"Youssef",url:"https://www.msr-inria.fr/researchers/youssef-hamadi/"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],acceptance:"24%, 23/96",role:"Proceedings of the 29th IEEE International Symposium on Software Reliability Engineering (ISSRE 2018)"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/1803.08725",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"/slide_bikiniproxy.pdf"}},[e._v("Slide")]),e._v(" • "),a("a",{attrs:{href:"https://github.com/Spirals-Team/bikiniproxy/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Alleviating Patch Overfitting with Automatic Test Generation: A Study of Feasibility and Effectiveness for the Nopol Repair System",url:"https://hal.inria.fr/hal-01774223/",date:"2018",description:"Among the many different kinds of program repair techniques, one widely studied family of techniques is called test suite based repair. However, test suites are in essence input-output specifications and are thus typically inadequate for completely specifying the expected behavior of the program under repair. Consequently, the patches generated by test suite based repair techniques can just overfit to the used test suite, and fail to generalize to other tests. We deeply analyze the overfitting problem in program repair and give a classification of this problem. This classification will help the community to better understand and design techniques to defeat the overfitting problem. We further propose and evaluate an approach called UnsatGuided, which aims to alleviate the overfitting problem for synthesis-based repair techniques with automatic test case generation. The approach uses additional automatically generated tests to strengthen the repair constraint used by synthesis-based repair techniques. We analyze the effectiveness of UnsatGuided: 1) analytically with respect to alleviating two different kinds of overfitting issues; 2) empirically based on an experiment over the 224 bugs of the Defects4J repository. The main result is that automatic test generation is effective in alleviating one kind of overfitting issue–regression introduction, but due to oracle problem, has minimal positive impact on alleviating the other kind of overfitting issue–incomplete fixing.",authors:[{lastname:"Yu",firstname:"Zhongxing",url:"https://sites.google.com/site/yuzxpage/"},{lastname:"Martinez",firstname:"Matias",url:"http://www.martinezmatias.com/"},{lastname:"Danglot",firstname:"Benjamin",url:"https://danglotb.github.io/"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],role:"Proceedings at Empirical Software Engineering (EMSE)"}}),e._v(" "),a("a",{attrs:{href:"https://hal.inria.fr/hal-01774223/",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/Spirals-Team/test4repair-experiments",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Exhaustive Exploration of the Failure-oblivious Computing Search Space",url:"https://arxiv.org/abs/1710.09722",date:"2018",description:"High-availability of software systems requires automated handling of crashes in presence of errors. Failure-oblivious computing is one technique that aims to achieve high availability. We note that failure-obliviousness has not been studied in depth yet, and there is very few study that helps understand why failure-oblivious techniques work. In order to make failure-oblivious computing to have an impact in practice, we need to deeply understand failure-oblivious behaviors in software. In this paper, we study, design and perform an experiment that analyzes the size and the diversity of the failure-oblivious behaviors. Our experiment consists of exhaustively computing the search space of 16 field failures of large-scale open-source Java software. The outcome of this experiment is a much better understanding of what really happens when failure-oblivious computing is used, and this opens new promising research directions.",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Hamadi",firstname:"Youssef",url:"https://www.msr-inria.fr/researchers/youssef-hamadi/"},{lastname:"Yu",firstname:"Zhongxing",url:"https://sites.google.com/site/yuzxpage/"},{lastname:"Baudry",firstname:"Benoit",url:"https://softwarediversity.eu/"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],acceptance:"25%, 30/119",role:"Proceedings of the 11th IEEE Conference on Software Testing, Validation and Verification (ICST'18)"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/1710.09722",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"/slide_failure_oblivious_search_space.pdf"}},[e._v("Slide")]),e._v(" • "),a("a",{attrs:{href:"https://github.com/Spirals-Team/runtime-repair-experiments",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Dissection of a Bug Dataset: Anatomy of 395 Patches from Defects4J",url:"https://arxiv.org/abs/1801.06393",date:"2018",description:"Well-designed and publicly available datasets of bugs are an invaluable asset to advance research fields such as fault localization and program repair as they allow directly and fairly comparison between competing techniques and also the replication of experiments. These datasets need to be deeply understood by researchers: the answer for questions like 'which bugs can my technique handle?' and 'for which bugs is my technique effective?'' depends on the comprehension of properties related to bugs and their patches. However, such properties are usually not included in the datasets, and there is still no widely adopted methodology for characterizing bugs and patches. In this work, we deeply study 395 patches of the Defects4J dataset. Quantitative properties (patch size and spreading) were automatically extracted, whereas qualitative ones (repair actions and patterns) were manually extracted using a thematic analysis-based approach. We found that 1) the median size of Defects4J patches is four lines, and almost 30% of the patches contain only addition of lines; 2) 92% of the patches change only one file, and 38% has no spreading at all; 3) the top-3 most applied repair actions are addition of method calls, conditionals, and assignments, occurring in 77% of the patches; and 4) nine repair patterns were found for 95% of the patches, where the most prevalent, appearing in 43% of the patches, is on conditional blocks. These results are useful for researchers to perform advanced analysis on their techniques' results based on Defects4J. Moreover, our set of properties can be used to characterize and compare different bug datasets.",authors:[{lastname:"Sobreira",firstname:"Victor"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Madeiral",firstname:"Fernanda",url:"https://fermadeiral.github.io/"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"},{lastname:"Maia",firstname:"Marcelo de Almeida",url:"http://lascam.facom.ufu.br/"}],acceptance:"27%, 39/146",role:"Proceedings of the 25th IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER'18)"}}),e._v(" "),a("a",{attrs:{href:"https://arxiv.org/abs/1801.06393",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/program-repair/defects4j-dissection/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"http://program-repair.org/defects4j-dissection/",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebSite"),a("OutboundLink")],1)],1)])]),e._v(" "),a("h3",{attrs:{id:"_2017-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2017-3","aria-hidden":"true"}},[e._v("#")]),e._v(" 2017 (3)")]),e._v(" "),a("ul",[a("li",[a("p",[a("cv",{attrs:{name:"Production-Driven Patch Generation",url:"https://hal.archives-ouvertes.fr/hal-01463689/document",date:"2017",description:"We present an original concept for patch generation: we propose to do it directly in production. Our idea is to generate patches on-the-fly based on automated analysis of the failure context. By doing this in production, the repair process has complete access to the system state at the point of failure. We propose to perform live regression testing of the generated patches directly on the production traffic, by feeding a sandboxed version of the application with a copy of the production traffic, the 'shadow traffic'. Our concept widens the applicability of program repair because it removes the requirements of having a failing test case.",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Hamadi",firstname:"Youssef",url:"https://www.msr-inria.fr/researchers/youssef-hamadi/"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],acceptance:"16%, 14/85",role:"Proceeding of ICSE NIER"}}),e._v(" "),a("a",{attrs:{href:"https://hal.archives-ouvertes.fr/hal-01463689/document",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"/slide_itzal.pdf"}},[e._v("Slide")])],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Dynamic Patch Generation for Null Pointer Exceptions Using Metaprogramming",url:"https://hal.archives-ouvertes.fr/hal-01419861/document",date:"2017",description:"Null pointer exceptions (NPE) are the number one cause of uncaught crashing exceptions in production. In this paper, we aim at exploring the search space of possible patches for null pointer exceptions with metaprogramming. Our idea is to transform the program under repair with automated code transformation, so as to obtain a metaprogram. This metaprogram contains automatically injected hooks, that can be activated to emulate a null pointer exception patch. This enables us to perform a fine-grain analysis of the runtime context of null pointer exceptions. We set up an experiment with 16 real null pointer exceptions that have happened in the field. We compare the effectiveness of our metaprogramming approach against simple templates for repairing null pointer exceptions.",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Cornu",firstname:"Benoit"},{lastname:"Seinturier",firstname:"Lionel",url:"http://www.lifl.fr/~seinturi/"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],acceptance:"24%, 34/135",role:"Proceedings of the 25th IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER'17)"}}),e._v(" "),a("a",{attrs:{href:"https://hal.archives-ouvertes.fr/hal-01419861/document",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"/slide_npefix.pdf"}},[e._v("Slide")]),e._v(" • "),a("a",{attrs:{href:"https://github.com/Spirals-Team/npefix/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/Spirals-Team/npefix-experiments",target:"_blank",rel:"noopener noreferrer"}},[e._v("Experiment Results"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Automatic repair of real bugs in java: a large-scale experiment on the defects4j dataset",url:"http://link.springer.com/article/10.1007/s10664-016-9470-4",date:"2016",description:"Defects4J is a large, peer-reviewed, structured dataset of real-world Java bugs. Each bug in Defects4J comes with a test suite and at least one failing test case that triggers the bug. In this paper, we report on an experiment to explore the effectiveness of automatic test-suite based repair on Defects4J. The result of our experiment shows that the considered state-of-the-art repair methods can generate patches for 47 out of 224 bugs. However, those patches are only test-suite adequate, which means that they pass the test suite and may potentially be incorrect beyond the test-suite satisfaction correctness criterion. We have manually analyzed 84 different patches to assess their real correctness. In total, 9 real Java bugs can be correctly repaired with a test-suite based repair. This analysis shows that test-suite based repair suffers from under-specified bugs, for which trivial or incorrect patches still pass the test suite. With respect to practical applicability, it takes on average 14.8 minutes to find a patch. The experiment was done on a scientific grid, totaling 17.6 days of computation time. All the repair systems and experimental results are publicly available on Github in order to facilitate future research on automatic repair.",authors:[{lastname:"Martinez",firstname:"Matias",url:"http://www.martinezmatias.com/"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Sommerard",firstname:"Romain"},{lastname:"Xuan",firstname:"Jifeng",url:"http://jifeng-xuan.com/"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],role:"Proceedings at Empirical Software Engineering (EMSE)"}}),e._v(" "),a("a",{attrs:{href:"http://link.springer.com/article/10.1007/s10664-016-9470-4",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"/slide_defects4j_repair.pdf"}},[e._v("Slide")]),e._v(" • "),a("a",{attrs:{href:"https://github.com/Spirals-Team/defects4j-repair/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Experiment Results"),a("OutboundLink")],1)],1)])]),e._v(" "),a("h3",{attrs:{id:"_2016-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2016-3","aria-hidden":"true"}},[e._v("#")]),e._v(" 2016 (3)")]),e._v(" "),a("ul",[a("li",[a("p",[a("cv",{attrs:{name:"Nopol: Automatic Repair of Conditional Statement Bugs in Java Programs",url:"https://hal.archives-ouvertes.fr/hal-01285008/document",date:"2016",description:"We propose Nopol, an approach to automatic repair of buggy conditional statements (i.e., if-then-else statements). This approach takes a buggy program as well as a test suite as input and generates a patch with a conditional expression as output. The test suite is required to contain passing test cases to model the expected behavior of the program and at least one failing test case that reveals the bug to be repaired. The process of Nopol consists of three major phases. First, Nopol employs angelic fix localization to identify expected values of a condition during the test execution. Second, runtime trace collection is used to collect variables and their actual values, including primitive data types and objected-oriented features (e.g., nullness checks), to serve as building blocks for patch generation. Third, Nopol encodes these collected data into an instance of a Satisfiability Modulo Theory (SMT) problem; then a feasible solution to the SMT instance is translated back into a code patch. We evaluate Nopol on 22 real-world bugs (16 bugs with a buggy if conditions and six bugs with missing preconditions) on two large open-source projects, namely Apache Commons Math and Apache Commons Lang. Empirical analysis on these bugs shows that our approach can effectively fix bugs with buggy if conditions and missing preconditions. We illustrate the capabilities and limitations of Nopol using case studies of real bug fixes.",authors:[{lastname:"Xuan",firstname:"Jifeng",url:"http://jifeng-xuan.com/"},{lastname:"Martinez",firstname:"Matias",url:"http://www.martinezmatias.com/"},{lastname:"Demarco",firstname:"Favio"},{lastname:"Clement",firstname:"Maxime"},{lastname:"Lamelas Marcote",firstname:"Sebastian"},{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Le Berre",firstname:"Daniel"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],role:"IEEE Transactions on Software Engineering, Institute of Electrical and Electronics Engineers (TSE)"}}),e._v(" "),a("a",{attrs:{href:"https://hal.archives-ouvertes.fr/hal-01285008/document",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/SpoonLabs/nopol",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/SpoonLabs/nopol-experiments",target:"_blank",rel:"noopener noreferrer"}},[e._v("Experiment Results"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"DynaMoth: Dynamic Code Synthesis for Automatic Program Repair",url:"https://hal.archives-ouvertes.fr/hal-01279233/document",date:"2016",description:"Automatic software repair is the process of automatically fixing bugs. The Nopol repair system repairs Java code using code synthesis. We have designed a new code synthesis engine for Nopol based on dynamic exploration, it is called DynaMoth. The main design goal is to be able to generate patches with method calls. We evaluate DynaMoth over 224 of the Defects4J dataset. The evaluation shows that Nopol with DynaMoth is capable of synthesizing patches and enables Nopol to repair new bugs of the dataset.",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}],role:"11th International Workshop in Automation of Software Test (AST 2016)"}}),e._v(" "),a("a",{attrs:{href:"https://hal.archives-ouvertes.fr/hal-01279233/document",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"/slide_dynamoth.pdf"}},[e._v("Slide")]),e._v("  • "),a("a",{attrs:{href:"https://github.com/SpoonLabs/nopol",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source code"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"IntroClassJava: A Benchmark of 297 Small and Buggy Java Programs",url:"https://hal.archives-ouvertes.fr/hal-01272126/document",date:"2016",description:"Reproducible and comparative research requires well-designed and publicly available benchmarks. We present IntroClassJava, a benchmark of 297 small Java programs, specified by JUnit test cases, and usable by any fault localization or repair system for Java. The dataset is based on the IntroClass benchmark and is publicly available on Github. ",authors:[{lastname:"Durieux",firstname:"Thomas",url:"https://durieux.me"},{lastname:"Monperrus",firstname:"Martin",url:"https://www.monperrus.net/martin/"}]}}),e._v(" "),a("a",{attrs:{href:"https://hal.archives-ouvertes.fr/hal-01272126/document",target:"_blank",rel:"noopener noreferrer"}},[e._v("PDF"),a("OutboundLink")],1),e._v(" • "),a("a",{attrs:{href:"https://github.com/Spirals-Team/IntroClassJava",target:"_blank",rel:"noopener noreferrer"}},[e._v("Benchmark"),a("OutboundLink")],1)],1)])]),e._v(" "),a("h2",{attrs:{id:"awards"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#awards","aria-hidden":"true"}},[e._v("#")]),e._v(" AWARDS")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Distinguished Paper")]),e._v(": A Longitudinal Analysis of Bloated Java Dependencies, ESEC/FSE'21")]),e._v(" "),a("li",[a("strong",[e._v("Best Paper")]),e._v(": DUETS: A Dataset of Reproducible Pairs of Java Library-Clients, MSR 2021")]),e._v(" "),a("li",[a("strong",[e._v("Distinguished Paper")]),e._v(": Empirical Review of Java Program Repair Tools: A Large-Scale Experiment on 2,141 Bugs and 23,551 Repair Attempts, ESEC/FSE'19")]),e._v(" "),a("li",[a("strong",[e._v("Best Thesis")]),e._v(": Accessit price for the Best Thesis GDR GPL 2018 (French Software Engenerring Group)")]),e._v(" "),a("li",[a("strong",[e._v("Best Paper")]),e._v(": A Comprehensive Study of Automatic Program Repair on the QuixBugs Benchmark, IBF 2019")]),e._v(" "),a("li",[e._v("Nominated "),a("strong",[e._v("Best Paper")]),e._v(":  Fully Automated HTML and Javascript Rewriting for Constructing a Self-healing Web Proxy, ISSRE 2018")]),e._v(" "),a("li",[a("strong",[e._v("Best Paper")]),e._v(": Towards an automated approach for bug fix pattern detection, VEM 2018")])]),e._v(" "),a("h2",{attrs:{id:"ph-d-thesis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ph-d-thesis","aria-hidden":"true"}},[e._v("#")]),e._v(" Ph.D. THESIS")]),e._v(" "),a("p",[a("strong",[e._v("Title")]),e._v(": "),a("em",[e._v("From Runtime Failures to Patches: Study of Patch Generation in Production")])]),e._v(" "),a("p",[a("strong",[e._v("Directors")]),e._v(": Martin Monperrus and Lionel Seinturier")]),e._v(" "),a("p",[a("strong",[e._v("Started in")]),e._v(": September 2015, "),a("strong",[e._v("Defended")]),e._v(": 25th September 2018")]),e._v(" "),a("p",[a("strong",[e._v("Slide")]),e._v(": "),a("a",{attrs:{href:"/slide_phd_defense_thomas_durieux.pdf"}},[e._v("Defense slide")])]),e._v(" "),a("h2",{attrs:{id:"open-source-research-tools"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#open-source-research-tools","aria-hidden":"true"}},[e._v("#")]),e._v(" OPEN-SOURCE RESEARCH TOOLS")]),e._v(" "),a("ul",[a("li",[a("p",[a("cv",{attrs:{name:"BikiniProxy",url:"https://github.com/Spirals-Team/bikiniproxy/",description:"",role:"Automatic Patch Generation Technique for Client-side JavaScript Applications"}}),e._v(" "),a("a",{attrs:{href:"https://github.com/Spirals-Team/bikiniproxy/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Github"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Itzal",url:"https://github.com/Spirals-Team/itzal-runtime-repair",description:"",role:"Automatic Patch Generation Technique for Java Server"}}),e._v(" "),a("a",{attrs:{href:"https://github.com/Spirals-Team/itzal",target:"_blank",rel:"noopener noreferrer"}},[e._v("Github"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"maven-repair",url:"https://github.com/Spirals-Team/maven-repair",description:"",role:"Maven Plugin to Automatic Generate  Patches for your Projects"}}),e._v(" "),a("a",{attrs:{href:"https://github.com/Spirals-Team/maven-repair",target:"_blank",rel:"noopener noreferrer"}},[e._v("Github"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"Nopol",url:"https://github.com/SpoonLabs/nopol/",description:"",role:"Automatic Patch Generation for Java"}}),e._v(" "),a("a",{attrs:{href:"https://github.com/SpoonLabs/nopol/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Github"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"DynaMoth",url:"https://github.com/SpoonLabs/nopol/",description:"",role:"Automatic Patch Synthesizer for Java"}}),e._v(" "),a("a",{attrs:{href:"https://github.com/SpoonLabs/nopol/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Github"),a("OutboundLink")],1)],1)]),e._v(" "),a("li",[a("p",[a("cv",{attrs:{name:"NPEFix",url:"https://github.com/Spirals-Team/npefix",description:"",role:"Automatic Patch Generation for Null Pointer Exception"}}),e._v(" "),a("a",{attrs:{href:"https://github.com/Spirals-Team/npefix",target:"_blank",rel:"noopener noreferrer"}},[e._v("Github"),a("OutboundLink")],1)],1)])])])},[],!1,null,null,null);t.default=s.exports}}]);